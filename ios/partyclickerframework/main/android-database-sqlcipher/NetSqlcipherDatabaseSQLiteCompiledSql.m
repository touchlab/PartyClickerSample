//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_source.h"
#include "NetSqlcipherDatabaseDatabaseObjectNotClosedException.h"
#include "NetSqlcipherDatabaseSQLiteCompiledSql.h"
#include "NetSqlcipherDatabaseSQLiteDatabase.h"
#include "NetSqlcipherDatabaseSQLiteDebug.h"
#include "android/util/Log.h"
#include "java/lang/IllegalStateException.h"

@interface NetSqlcipherDatabaseSQLiteCompiledSql () {
 @public
  NSString *mSqlStmt_;
  NSException *mStackTrace_;
  jboolean mInUse_;
}

- (void)compileWithNSString:(NSString *)sql
                withBoolean:(jboolean)forceCompilation;

- (void)native_compileWithNSString:(NSString *)sql;

- (void)native_finalize;

@end

J2OBJC_FIELD_SETTER(NetSqlcipherDatabaseSQLiteCompiledSql, mSqlStmt_, NSString *)
J2OBJC_FIELD_SETTER(NetSqlcipherDatabaseSQLiteCompiledSql, mStackTrace_, NSException *)

inline NSString *NetSqlcipherDatabaseSQLiteCompiledSql_get_TAG();
static NSString *NetSqlcipherDatabaseSQLiteCompiledSql_TAG = @"SQLiteCompiledSql";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetSqlcipherDatabaseSQLiteCompiledSql, TAG, NSString *)

__attribute__((unused)) static void NetSqlcipherDatabaseSQLiteCompiledSql_compileWithNSString_withBoolean_(NetSqlcipherDatabaseSQLiteCompiledSql *self, NSString *sql, jboolean forceCompilation);

void NetSqlcipherDatabaseSQLiteCompiledSql_native_compileWithNSString_(NetSqlcipherDatabaseSQLiteCompiledSql *self, NSString *sql);

void NetSqlcipherDatabaseSQLiteCompiledSql_native_finalize(NetSqlcipherDatabaseSQLiteCompiledSql *self);

@implementation NetSqlcipherDatabaseSQLiteCompiledSql

- (instancetype)initWithNetSqlcipherDatabaseSQLiteDatabase:(NetSqlcipherDatabaseSQLiteDatabase *)db
                                              withNSString:(NSString *)sql {
  NetSqlcipherDatabaseSQLiteCompiledSql_initWithNetSqlcipherDatabaseSQLiteDatabase_withNSString_(self, db, sql);
  return self;
}

- (void)compileWithNSString:(NSString *)sql
                withBoolean:(jboolean)forceCompilation {
  NetSqlcipherDatabaseSQLiteCompiledSql_compileWithNSString_withBoolean_(self, sql, forceCompilation);
}

- (void)releaseSqlStatement {
  if (nStatement_ != 0) {
    if (JreLoadStatic(NetSqlcipherDatabaseSQLiteDebug, DEBUG_ACTIVE_CURSOR_FINALIZATION)) {
      AndroidUtilLog_vWithNSString_withNSString_(NetSqlcipherDatabaseSQLiteCompiledSql_TAG, JreStrcat("$JC", @"closed and deallocated DbObj (id#", nStatement_, ')'));
    }
    @try {
      [((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(mDatabase_)) lock];
      NetSqlcipherDatabaseSQLiteCompiledSql_native_finalize(self);
      nStatement_ = 0;
    }
    @finally {
      [((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(mDatabase_)) unlock];
    }
  }
}

- (jboolean)acquire {
  @synchronized(self) {
    if (mInUse_) {
      return false;
    }
    mInUse_ = true;
    if (JreLoadStatic(NetSqlcipherDatabaseSQLiteDebug, DEBUG_ACTIVE_CURSOR_FINALIZATION)) {
      AndroidUtilLog_vWithNSString_withNSString_(NetSqlcipherDatabaseSQLiteCompiledSql_TAG, JreStrcat("$J$", @"Acquired DbObj (id#", nStatement_, @") from DB cache"));
    }
    return true;
  }
}

- (void)release__ {
  @synchronized(self) {
    if (JreLoadStatic(NetSqlcipherDatabaseSQLiteDebug, DEBUG_ACTIVE_CURSOR_FINALIZATION)) {
      AndroidUtilLog_vWithNSString_withNSString_(NetSqlcipherDatabaseSQLiteCompiledSql_TAG, JreStrcat("$J$", @"Released DbObj (id#", nStatement_, @") back to DB cache"));
    }
    mInUse_ = false;
  }
}

- (void)java_finalize {
  @try {
    if (nStatement_ == 0) return;
    if (JreLoadStatic(NetSqlcipherDatabaseSQLiteDebug, DEBUG_ACTIVE_CURSOR_FINALIZATION)) {
      AndroidUtilLog_vWithNSString_withNSString_(NetSqlcipherDatabaseSQLiteCompiledSql_TAG, JreStrcat("$JC", @"** warning ** Finalized DbObj (id#", nStatement_, ')'));
    }
    jint len = [((NSString *) nil_chk(mSqlStmt_)) java_length];
    AndroidUtilLog_wWithNSString_withNSString_withNSException_(NetSqlcipherDatabaseSQLiteCompiledSql_TAG, JreStrcat("$$", @"Releasing statement in a finalizer. Please ensure that you explicitly call close() on your cursor: ", [((NSString *) nil_chk(mSqlStmt_)) java_substring:0 endIndex:(len > 100) ? 100 : len]), mStackTrace_);
    [self releaseSqlStatement];
  }
  @finally {
    [super java_finalize];
  }
}

- (void)native_compileWithNSString:(NSString *)sql {
  NetSqlcipherDatabaseSQLiteCompiledSql_native_compileWithNSString_(self, sql);
}

- (void)native_finalize {
  NetSqlcipherDatabaseSQLiteCompiledSql_native_finalize(self);
}

- (void)dealloc {
  JreCheckFinalize(self, [NetSqlcipherDatabaseSQLiteCompiledSql class]);
  RELEASE_(mDatabase_);
  RELEASE_(mSqlStmt_);
  RELEASE_(mStackTrace_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x20, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x20, 3, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 4, -1, 5, -1, -1, -1 },
    { NULL, "V", 0x112, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x112, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithNetSqlcipherDatabaseSQLiteDatabase:withNSString:);
  methods[1].selector = @selector(compileWithNSString:withBoolean:);
  methods[2].selector = @selector(releaseSqlStatement);
  methods[3].selector = @selector(acquire);
  methods[4].selector = @selector(release__);
  methods[5].selector = @selector(java_finalize);
  methods[6].selector = @selector(native_compileWithNSString:);
  methods[7].selector = @selector(native_finalize);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 8, -1, -1 },
    { "mDatabase_", "LNetSqlcipherDatabaseSQLiteDatabase;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "nHandle_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "nStatement_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mSqlStmt_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStackTrace_", "LNSException;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInUse_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNetSqlcipherDatabaseSQLiteDatabase;LNSString;", "compile", "LNSString;Z", "release", "finalize", "LNSException;", "native_compile", "LNSString;", &NetSqlcipherDatabaseSQLiteCompiledSql_TAG };
  static const J2ObjcClassInfo _NetSqlcipherDatabaseSQLiteCompiledSql = { "SQLiteCompiledSql", "net.sqlcipher.database", ptrTable, methods, fields, 7, 0x0, 8, 7, -1, -1, -1, -1, -1 };
  return &_NetSqlcipherDatabaseSQLiteCompiledSql;
}

@end

void NetSqlcipherDatabaseSQLiteCompiledSql_initWithNetSqlcipherDatabaseSQLiteDatabase_withNSString_(NetSqlcipherDatabaseSQLiteCompiledSql *self, NetSqlcipherDatabaseSQLiteDatabase *db, NSString *sql) {
  NSObject_init(self);
  self->nHandle_ = 0;
  self->nStatement_ = 0;
  JreStrongAssign(&self->mSqlStmt_, nil);
  JreStrongAssign(&self->mStackTrace_, nil);
  self->mInUse_ = false;
  if (![((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(db)) isOpen]) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$$", @"database ", [db getPath], @" already closed"));
  }
  JreStrongAssign(&self->mDatabase_, db);
  JreStrongAssign(&self->mSqlStmt_, sql);
  JreStrongAssign(&self->mStackTrace_, [create_NetSqlcipherDatabaseDatabaseObjectNotClosedException_init() fillInStackTrace]);
  self->nHandle_ = db->mNativeHandle_;
  NetSqlcipherDatabaseSQLiteCompiledSql_compileWithNSString_withBoolean_(self, sql, true);
}

NetSqlcipherDatabaseSQLiteCompiledSql *new_NetSqlcipherDatabaseSQLiteCompiledSql_initWithNetSqlcipherDatabaseSQLiteDatabase_withNSString_(NetSqlcipherDatabaseSQLiteDatabase *db, NSString *sql) {
  J2OBJC_NEW_IMPL(NetSqlcipherDatabaseSQLiteCompiledSql, initWithNetSqlcipherDatabaseSQLiteDatabase_withNSString_, db, sql)
}

NetSqlcipherDatabaseSQLiteCompiledSql *create_NetSqlcipherDatabaseSQLiteCompiledSql_initWithNetSqlcipherDatabaseSQLiteDatabase_withNSString_(NetSqlcipherDatabaseSQLiteDatabase *db, NSString *sql) {
  J2OBJC_CREATE_IMPL(NetSqlcipherDatabaseSQLiteCompiledSql, initWithNetSqlcipherDatabaseSQLiteDatabase_withNSString_, db, sql)
}

void NetSqlcipherDatabaseSQLiteCompiledSql_compileWithNSString_withBoolean_(NetSqlcipherDatabaseSQLiteCompiledSql *self, NSString *sql, jboolean forceCompilation) {
  if (![((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(self->mDatabase_)) isOpen]) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$$", @"database ", [((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(self->mDatabase_)) getPath], @" already closed"));
  }
  if (forceCompilation) {
    [((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(self->mDatabase_)) lock];
    @try {
      NetSqlcipherDatabaseSQLiteCompiledSql_native_compileWithNSString_(self, sql);
    }
    @finally {
      [((NetSqlcipherDatabaseSQLiteDatabase *) nil_chk(self->mDatabase_)) unlock];
    }
  }
}

JNIEXPORT void Java_net_sqlcipher_database_SQLiteCompiledSql_native_1compile(JNIEnv *_env_, jobject self, jstring sql);

void NetSqlcipherDatabaseSQLiteCompiledSql_native_compileWithNSString_(NetSqlcipherDatabaseSQLiteCompiledSql *self, NSString *sql) {
  Java_net_sqlcipher_database_SQLiteCompiledSql_native_1compile(&J2ObjC_JNIEnv, self, sql);
}

JNIEXPORT void Java_net_sqlcipher_database_SQLiteCompiledSql_native_1finalize(JNIEnv *_env_, jobject self);

void NetSqlcipherDatabaseSQLiteCompiledSql_native_finalize(NetSqlcipherDatabaseSQLiteCompiledSql *self) {
  Java_net_sqlcipher_database_SQLiteCompiledSql_native_1finalize(&J2ObjC_JNIEnv, self);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetSqlcipherDatabaseSQLiteCompiledSql)
